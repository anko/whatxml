# whatxml

Sick of writing rigid XML or HTML templates? Turns out [LiveScript]'s
[cascades] are a great syntax for nested structures:

    x = whatxml \html
      .. \head
        .. \title ._ "An example"
        ..comment "Secrets!"
      .. \body
        .. \h1
          .. class : "top-heading"
          .._ "An example"
        .. \p
          .._ "Here's a link: "
          .. \a
            .._ "to github"
            .. href : "https://github.com"
          .._ " and some more text after it."
          ..raw "\n<strong>Maybe embed <em>Markdown</em> output here.</strong>\n"
        .. \hr true # self-closing
        .. \p
          .._ "A second paragraph."

    console.log x.to-string!

That gives you this (I ran it through `xmllint --html -` for a doctype
declaration and formatting):

    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
    <html>
    <head>
    <title>An example</title>
    <!--Secrets!-->
    </head>
    <body>
    <h1 class="top-heading">An example</h1>
    <p>Here's a link: <a href="https://github.com">to github</a> and some more text after it.
    <strong>Raw text is <em>great</em> for markdown output.</strong>
    </p>
    <hr>
    <p>A second paragraph.</p>
    </body>
    </html>

# Why?

[LiveScript]'s callable property-access-[cascades] are a great syntax for
nesting structures which aren't usually nestable (as function calls here). This
makes for a clean templating DSL and I hadn't seen it tried.

Definitely inspired by substack's [hyperglue].

# Can plain JavaScript do this?

Semantically: Yes. LiveScript compiles into JavaScript.

Syntactically: *No*. Here's the JavaScript that the above compiles to:

    // Generated by LiveScript 1.2.0 (function(){
      var whatxml, x$, x, y$, z$, z1$, z2$, z3$, z4$;
      whatxml = require('./whatxml.ls');
      x$ = x = whatxml('html');
      y$ = x$('head');
      y$('title')._("An example");
      y$.comment("Secrets!");
      z$ = x$('body');
      z1$ = z$('h1');
      z1$.attr("class", "top-heading");
      z1$._("An example");
      z2$ = z$('p');
      z2$._("Here's a link: ");
      z3$ = z2$('a');
      z3$._("to github");
      z3$.attr('href', "https://github.com");
      z2$._(" and some more text after it.");
      z2$.raw("\n<strong>Raw text is <em>great</em> for markdown output.</strong>\n");
      z$('hr', true);
      z4$ = z$('p');
      z4$._("A second paragraph.");
      console.log(x.toString());
    }).call(this);


Ew.

You could of course write your templates in LiveScript and automatically
compile it when necessary. Then you'll have mostly reimplemented [Handlebars]
with a different syntax. :)

# Try it

It's not on NPM (yet), but you can clone this repo and

    npm install

Then just point your `require` to the root directory.


 [browserify]: http://browserify.org/
 [hyperglue]: https://github.com/substack/hyperglue
 [Handlebars]: http://handlebarsjs.com/
 [LiveScript]: http://livescript.net/
 [cascades]: http://livescript.net/#property-access-cascades
